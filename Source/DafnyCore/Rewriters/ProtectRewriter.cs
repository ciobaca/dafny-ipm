#nullable enable
using Microsoft.Boogie;
using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Diagnostics.Contracts;
using System.Linq;

namespace Microsoft.Dafny;
public class ProtectRewriter(ErrorReporter r) : IRewriter(r) { // TODO: Figure out if the class can Extend Rewriter instead of IRewriter
  private class ExprReplacer {
    public static Expression ReplaceExpr(Expression e) => e switch {
      ApplyExpr p                           => ReplaceExprParticular(p),
      FunctionCallExpr p                    => ReplaceExprParticular(p),
      MemberSelectExpr p                    => ReplaceExprParticular(p),
      MultiSelectExpr p                     => ReplaceExprParticular(p),
      SeqSelectExpr p                       => ReplaceExprParticular(p),
      ThisExpr p                            => p switch {
        ImplicitThisExpr pp => pp switch {
          ImplicitThisExprConstructorCall ppp => ReplaceExprParticular(ppp),
          _ => ReplaceExprParticular(pp), },
        _ => ReplaceExprParticular(p), },
      DisplayExpression p                   => p switch {
        SeqDisplayExpr pp      => ReplaceExprParticular(pp),
        SetDisplayExpr pp      => ReplaceExprParticular(pp),
        MultiSetDisplayExpr pp => ReplaceExprParticular(pp),
        _ => ReplaceExprParticular(p), },
      MapDisplayExpr p                      => ReplaceExprParticular(p),
      MultiSetFormingExpr p                 => ReplaceExprParticular(p),
      SeqConstructionExpr p                 => ReplaceExprParticular(p),
      SeqUpdateExpr p                       => ReplaceExprParticular(p),
      ComprehensionExpr p                   => p switch {
        LambdaExpr pp       => ReplaceExprParticular(pp),
        MapComprehension pp => ReplaceExprParticular(pp),
        QuantifierExpr pp   => pp switch {
          ForallExpr ppp  => ReplaceExprParticular(ppp),
          ExistsExpr ppp  => ReplaceExprParticular(ppp),
          _ => ReplaceExprParticular(pp), },
        SetComprehension pp => ReplaceExprParticular(pp),
        _ => ReplaceExprParticular(p), },
      ITEExpr p                             => ReplaceExprParticular(p),
      NestedMatchExpr p                     => ReplaceExprParticular(p),
      TernaryExpr p                         => ReplaceExprParticular(p),
      DatatypeValue p                       => ReplaceExprParticular(p),
      FieldLocation p                       => ReplaceExprParticular(p),
      IndexFieldLocation p                  => ReplaceExprParticular(p),
      LocalsObjectExpression p              => ReplaceExprParticular(p),
      OldExpr p                             => ReplaceExprParticular(p),
      UnchangedExpr p                       => ReplaceExprParticular(p),
      WildcardExpr p                        => ReplaceExprParticular(p),
      BinaryExpr p                          => ReplaceExprParticular(p),
      DecreasesToExpr p                     => ReplaceExprParticular(p),
      UnaryExpr p                           => p switch {
        UnaryOpExpr pp    => pp switch {
          FreshExpr ppp => ReplaceExprParticular(ppp),
          _ => ReplaceExprParticular(pp), },
        TypeUnaryExpr pp  => pp switch {
          ConversionExpr ppp  => ReplaceExprParticular(ppp),
          TypeTestExpr ppp    => ReplaceExprParticular(ppp),
          _ => ReplaceExprParticular(pp), },
        _ => ReplaceExprParticular(p), },
      BoxingCastExpr p                      => ReplaceExprParticular(p),
      UnboxingCastExpr p                    => ReplaceExprParticular(p),
      IdentifierExpr p                      => p switch {
        AutoGhostIdentifierExpr pp  => ReplaceExprParticular(pp),
        ImplicitIdentifierExpr pp   => ReplaceExprParticular(pp),
        _ => ReplaceExprParticular(p), },
      LetExpr p                             => p switch {
        BoogieGenerator.SubstLetExpr pp => ReplaceExprParticular(pp),
        _ => ReplaceExprParticular(p), },
      ResolverIdentifierExpr p              => ReplaceExprParticular(p),
      ConcreteSyntaxExpression p            => p switch {
        NameSegment pp            => ReplaceExprParticular(pp),
        SuffixExpr pp             => pp switch {
          ApplySuffix ppp                   => ReplaceExprParticular(ppp),
          ExprDotName ppp                   => ReplaceExprParticular(ppp),
          FieldLocationExpression ppp       => ReplaceExprParticular(ppp),
          IndexFieldLocationExpression ppp  => ReplaceExprParticular(ppp),
          _ => ReplaceExprParticular(pp), },
        DatatypeUpdateExpr pp     => ReplaceExprParticular(pp),
        ChainingExpression pp     => ReplaceExprParticular(pp),
        ParensExpression pp       => pp switch {
          AutoGeneratedExpression ppp => ReplaceExprParticular(ppp),
          _ => ReplaceExprParticular(pp), },
        LetOrFailExpr pp          => ReplaceExprParticular(pp),
        DefaultValueExpression pp => pp switch {
          DefaultValueExpressionType ppp    => ReplaceExprParticular(ppp),
          DefaultValueExpressionPreType ppp => ReplaceExprParticular(ppp),
          _ => ReplaceExprParticular(pp), },
        NegationExpression pp     => ReplaceExprParticular(pp),
        _ => ReplaceExprParticular(p), },
      LiteralExpr p                         => p switch {
        StaticReceiverExpr pp => ReplaceExprParticular(pp),
        CharLiteralExpr pp    => ReplaceExprParticular(pp),
        StringLiteralExpr pp  => ReplaceExprParticular(pp),
        _ => ReplaceExprParticular(p), },
      StmtExpr p                            => ReplaceExprParticular(p),
      MatchExpr p                           => ReplaceExprParticular(p),
      BoogieGenerator.BoogieWrapper p       => ReplaceExprParticular(p),
      BoogieGenerator.BoogieFunctionCall p  => ReplaceExprParticular(p),
      _ => ReplaceExprParticular(e),
    };
    private static Expression NotImplemented(Expression e) {
      Console.WriteLine($"Dafny IPM: {e.GetType().Name} not yet implemented.");
      return e;
    }
    private static Expression ReplaceExprParticular(Expression e) => NotImplemented(e);
    private static Expression ReplaceExprParticular(StaticReceiverExpr e) => e;
    private static Expression ReplaceExprParticular(LiteralExpr e) => e;
    private static Expression ReplaceExprParticular(ThisExpr e) => ExpressionWrappedIn_Protect_Call(e);
    private static Expression ReplaceExprParticular(IdentifierExpr e) => ExpressionWrappedIn_Protect_Call(e);
    private static Expression ReplaceExprParticular(DatatypeValue e) => ExpressionWrappedIn_Protect_Call(e);
    private static Expression ReplaceExprParticular(NameSegment e) => ExpressionWrappedIn_Protect_Call(e);
    private static Expression ReplaceExprParticular(UnaryOpExpr e) {
      Contract.Assert(e.Op != UnaryOpExpr.Opcode.Fresh); // apparently this is unreachable since unary expressions are handled by the "FreshExpr" subclass
      return e.Op switch {
        UnaryOpExpr.Opcode.Cardinality  or
        UnaryOpExpr.Opcode.Allocated    or
        UnaryOpExpr.Opcode.Lit          or
        UnaryOpExpr.Opcode.Assigned     or
        UnaryOpExpr.Opcode.Not          => NotImplemented(e),
        _ => throw new UnreachableException(),
      };
    }
    private static Expression ReplaceExprParticular(BinaryExpr e) => new BinaryExpr(e.Origin, e.Op, ReplaceExpr(e.E0), ReplaceExpr(e.E1));
    private static Expression ReplaceExprParticular(ChainingExpression e) {
      if (e.PrefixLimits.Any(l => l is not null)) {
        return NotImplemented(e);
      }
      return new ChainingExpression(e.Origin, e.Operands.ConvertAll(ReplaceExpr), e.Operators, e.OperatorLocs, e.PrefixLimits);
    }
    private static Expression ReplaceExprParticular(ParensExpression e) => new ParensExpression(e.Origin, ReplaceExpr(e.E));
    private static Expression ReplaceExprParticular(DefaultValueExpression e) {
      Contract.Assert(e.WasResolved());
      Contract.Assert(e.Resolved is not null);
      return NotImplemented(e);
    }
    private static Expression ReplaceExprParticular(LetExpr e) => new LetExpr(e.Origin, e.LHSs, e.RHSs, ReplaceExpr(e.Body), e.Exact, e.Attributes);
  }

  //static ProtectRewriter() {
  //}

  public static readonly string ProtectFunctionName = "_protect";
  public static readonly string ProtectToProveFunctionName = "_protectToProve";
  public static readonly string ProtectScopeFunctionName = "_protectScope";

  #region Protector Functions
  private static TypeParameter simpleTypeVar(string name) => new(
    origin: SourceOrigin.NoToken,
    nameNode: new(name),
    varianceSyntax: TPVarianceSyntax.NonVariant_Strict,
    characteristics: TypeParameterCharacteristics.Default(),
    typeBounds: [],
    attributes: null
  );
  private static Function ProtectorFunctionWith(List<TypeParameter> typeArgs, string name, Type resultType, List<Formal> argTypes, Expression body) => new(
      origin: new Token(),
      // can't use SourceOrigin.NoToken because ref. eq. to it
      // is used to ensure that DefaultModuleDefinitions are verified;
      // I do NOT like that piece of code (:
      nameNode: new(name),
      hasStaticKeyword: false,
      isGhost: true,
      isOpaque: true,
      typeArgs: typeArgs,
      ins: argTypes,
      result: null,
      resultType: resultType,
      req: [],
      reads: new(),
      ens: [],
      decreases: new(),
      body: body,
      byMethodTok: null, byMethodBody: null,
      attributes: new(
        name: "auto_generated", args: [],
        prev: null
      ),
      signatureEllipsis: null
    );
  private static Formal ProtectorFormal_x(TypeParameter typeVar) => new(
    origin: SourceOrigin.NoToken,
    nameNode: new("x"),
    syntacticType: new UserDefinedType(typeVar),
    inParam: true,
    isGhost: false,
    defaultValue: null,
    attributes: null,
    isOld: false,
    isNameOnly: false,
    isOlder: false,
    nameForCompilation: null
  );
  private static Formal ProtectorFormal_name() => new(
    origin: SourceOrigin.NoToken,
    nameNode: new("name"),
    syntacticType: new UserDefinedType(
      origin: SourceOrigin.NoToken,
      name: "string",
      optTypeArgs: null
    ),
    inParam: true,
    isGhost: false,
    defaultValue: null,
    attributes: null,
    isOld: false,
    isNameOnly: false,
    isOlder: false,
    nameForCompilation: null
  );
  private static Function ProtectScopeFunction() {
    var typeVar = simpleTypeVar("T");
    return ProtectorFunctionWith(
      typeArgs: [typeVar,],
      name: ProtectScopeFunctionName,
      resultType: new BoolType(),
      argTypes: [
        ProtectorFormal_x(typeVar),
        ProtectorFormal_name(),
      ],
      body: new LiteralExpr(
        origin: SourceOrigin.NoToken,
        value: true
      )
    );
  }
  private static Function ProtectFunction() {
    var typeVar = simpleTypeVar("T");
    return ProtectorFunctionWith(
      typeArgs: [typeVar,],
      name: ProtectFunctionName,
      resultType: new UserDefinedType(typeVar),
      argTypes: [
        ProtectorFormal_x(typeVar),
        ProtectorFormal_name(),
      ],
      body: new NameSegment(
        origin: SourceOrigin.NoToken,
        name: "x",
        optTypeArguments: null
      )
    );
  }
  private static Function ProtectToProveFunction() {
    var typeVar = simpleTypeVar("T");
    return ProtectorFunctionWith(
      typeArgs: [typeVar,],
      name: ProtectToProveFunctionName,
      resultType: new UserDefinedType(typeVar),
      argTypes: [
        ProtectorFormal_x(typeVar),
        ProtectorFormal_name(),
        new(
          origin: SourceOrigin.NoToken,
          nameNode: new("scope"),
          syntacticType: new SeqType(new BoolType()),
          inParam: true,
          isGhost: false,
          defaultValue: null,
          attributes: null,
          isOld: false,
          isNameOnly: false,
          isOlder: false,
          nameForCompilation: null
        ),
      ],
      body: new NameSegment(
        origin: SourceOrigin.NoToken,
        name: "x",
        optTypeArguments: null
      )
    );
  }
  public static IReadOnlyList<Function> ProtectorFunctions() => [
    ProtectScopeFunction(),
    ProtectFunction(),
    ProtectToProveFunction(),
  ];
  #endregion

  // TODOs:
  //  - figure out where you can call (some SystemModuleManager).CreateArrowTypeDecl(2) directly or deferred

  internal override void PreResolve(Program program) {
    //var moduleDefinition = new ModuleDefinition(
    //  SourceOrigin.NoToken,
    //  new Name("_ITP"),
    //  [],
    //  ModuleKindEnum.Concrete,
    //  null,
    //  program.DefaultModuleDef,
    //  null,
    //  []
    //);
    //var sig = new ModuleSignature() {
    //  ModuleDef = moduleDefinition,
    //  IsAbstract = moduleDefinition.ModuleKind == ModuleKindEnum.Abstract,
    //  VisibilityScope = new()
    //};
    //sig.VisibilityScope.Augment(moduleDefinition.VisibilityScope);
    //Contract.Assert(moduleDefinition.DefaultClass is not null);
    //moduleDefinition.DefaultClass.Members.AddRange(ProtectorFunctions);
    //moduleDefinition.DefaultClass.SetMembersBeforeResolution();
    //program.DefaultModuleDef.SourceDecls.Add(new LiteralModuleDecl(Options, moduleDefinition, program.DefaultModuleDef, Guid.NewGuid()));
    //  program.SystemModuleManager.CreateArrowTypeDecl(2);// this doesn't work for some reason, prolly bcs it's done after parsing :(
  }
  internal override void PreResolve(ModuleDefinition moduleDefinition) {
    Contract.Requires(moduleDefinition.DefaultClass is not null);
    Contract.Requires(moduleDefinition.TopLevelDecls.OfType<AbstractModuleDecl>().None());
    Contract.Requires(moduleDefinition.TopLevelDecls.None(d => d is TypeParameter or AmbiguousTopLevelDecl
                                                                 or InternalTypeSynonymDecl or NonNullTypeDecl));
    //moduleDefinition.SourceDecls.Add(new AliasModuleDecl(
    //  Options,
    //  new SourceOrigin(Token.NoToken, Token.NoToken)/*maybe this'll work?*/,
    //  new([new("_ITP")]),
    //  new("_ITP"),
    //  null,
    //  moduleDefinition,
    //  true,
    //  [],
    //  Guid.NewGuid()
    //));
    moduleDefinition.TopLevelDecls.Where(d => d is not ModuleDecl).ForEach(ApplyChangesTo);
    moduleDefinition.DefaultClass!.Members = [.. ProtectorFunctions(), .. moduleDefinition.DefaultClass!.Members];
  }
  private static void ApplyChangesTo(TopLevelDecl d) {
    static IEnumerable<AssertStmt> assertStatementsOfExpression(Expression e) {
      if (e is StmtExpr statementExpression) {
        foreach (var assertStatementFromStatementExpression in assertStatementsOfStatement(statementExpression.S)) {
          yield return assertStatementFromStatementExpression;
        }
      }
      foreach (var assertStatementFromSubExpressions in e.SubExpressions.SelectMany(assertStatementsOfExpression)) {
        yield return assertStatementFromSubExpressions;
      }
    }
    static IEnumerable<AssertStmt> assertStatementsOfStatement(Statement s) {
      if (s is AssertStmt assertStatement) {
        yield return assertStatement;
      }
      foreach (var assertStatementFromSubStatement in s.SubStatements.SelectMany(assertStatementsOfStatement)) {
        yield return assertStatementFromSubStatement;
      }
    }

    static void ReplaceExpressionInAssertStatement(AssertStmt a) {
      if (Attributes.Contains(a.Attributes, "ipm")) {
        //Console.WriteLine("Protecting to prove assertion " + a.Expr.ToString());
        a.Expr = ExpressionWrappedIn_ProtectToProve_Call(a.Expr);
      } else {
        a.Expr = ExprReplacer.ReplaceExpr(a.Expr);
        //Console.WriteLine($"assert statement: {a.Expr}");
      }
    }

    switch (d) {
      case TopLevelDeclWithMembers decl:
        foreach (var member in decl.Members.OfType<MethodOrFunction>()) {
          foreach (var req in member.Req) {
            req.E = ExprReplacer.ReplaceExpr(req.E);
            //Console.WriteLine($"requires clause: {req.E}");
          }
          foreach (var ens in member.Ens) {
            if (Attributes.Contains(ens.Attributes, "ipm")) {
              //Console.WriteLine("Protecting to prove ensures clause " + ens.E.ToString());
              ens.E = ExpressionWrappedIn_ProtectToProve_Call(ens.E);
            } else {
              ens.E = ExprReplacer.ReplaceExpr(ens.E);
            }
            //Console.WriteLine($"ensures clause: {ens.E}");
          }
          switch (member) {
            case Function f:
              if (f.Body is null) { break; }
              assertStatementsOfExpression(f.Body).ForEach(ReplaceExpressionInAssertStatement);
              break;
            case MethodOrConstructor mc:
              if (mc.Body is null) { break; }
              mc.Body.Body.SelectMany(assertStatementsOfStatement).ForEach(ReplaceExpressionInAssertStatement);
              break;
            default:
              throw new UnreachableException();
          }
        }
        break;
      case SubsetTypeDecl decl:
        assertStatementsOfExpression(decl.Constraint).ForEach(ReplaceExpressionInAssertStatement);
        if (decl.Witness is not null) {
          assertStatementsOfExpression(decl.Witness).ForEach(ReplaceExpressionInAssertStatement);
        }
        break;
      case ConcreteTypeSynonymDecl:
        break;
      default:
        throw new UnreachableException();
    }
  }

  private static ApplySuffix ExpressionWrappedIn_Protect_Call(Expression expression) =>
    new(expression.Origin, null, new NameSegment(Token.NoToken, ProtectFunctionName, null), [
      new(null, expression),
      new(null, new StringLiteralExpr(SourceOrigin.NoToken, expression.ToString(), false)),
    ], Token.NoToken);

  private static Expression ExpressionWrappedIn_ProtectToProve_Call(Expression expression) => expression switch {
    LetExpr le => new LetExpr(le.Origin, le.LHSs, le.RHSs, new ProtectToProveApplySuffix(le.Body), le.Exact, le.Attributes),
    _ => new ProtectToProveApplySuffix(expression)
  };

  internal class ProtectToProveApplySuffix : ApplySuffix, ICloneable<ProtectToProveApplySuffix> {
    ProtectToProveApplySuffix ICloneable<ProtectToProveApplySuffix>.Clone(Cloner cloner) => new(cloner, this);
    public ProtectToProveApplySuffix(Cloner cloner, ProtectToProveApplySuffix original) : base(cloner, original) { }
    [SyntaxConstructor]
    public ProtectToProveApplySuffix(Expression e) : base(e.Origin, null, new NameSegment(Token.NoToken, ProtectToProveFunctionName, null), [
      new(null, ExprReplacer.ReplaceExpr(e)),
      new(null, new StringLiteralExpr(SourceOrigin.NoToken, e.ToString(), false)),
      new(null, new SeqDisplayExpr(SourceOrigin.NoToken, [])),
    ], Token.NoToken) { }

    public SeqDisplayExpr Seq => (Bindings.ArgumentBindings[2].Actual as SeqDisplayExpr)!;
    public bool isValidPreResolve => Seq is { Elements: [] };
    internal void AddScopeArgs(INewOrOldResolver resolver, ResolutionContext context) {
      Contract.Requires(isValidPreResolve);
      //static List<T?> getThingsFromScope<T>(Scope<T> s) where T : class =>
      //    (s.GetType()
      //      .GetField("things", System.Reflection.BindingFlags.Instance | System.Reflection.BindingFlags.NonPublic)!
      //      .GetValue(s) as List<T?>)!;
      //Seq.Elements.AddRange(getThingsFromScope(resolver.Scope).IgnoreNulls().Distinct().Select(v => {
      //  var e = VariableNameWrappedIn_ProtectScope_Call(v.Name);
      //  var ns = (e.Bindings.ArgumentBindings.First(b => b.Actual is NameSegment _ns && _ns.Name == v.Name).Actual as NameSegment)!;

      //  var id = new IdentifierExpr(SourceOrigin.NoToken, v);
      //  ns.ResolvedExpression = id;
      //  ns.Type = id.Type.UseInternalSynonym();
      //  return e;
      //}));
      Seq.Elements.AddRange(resolver.Scope.Names.IgnoreNulls().Distinct().Select(VariableNameWrappedIn_ProtectScope_Call));
      //System.Console.WriteLine('[' + string.Join(", ", Seq.Elements) + ']');
    }
  }

  private static ApplySuffix VariableNameWrappedIn_ProtectScope_Call(string varname) {
    Contract.Ensures(Contract.Result<ApplySuffix>().Bindings.ArgumentBindings.Any(b => b.Actual is NameSegment _ns && _ns.Name == varname));
    return new(SourceOrigin.NoToken, null, new NameSegment(Token.NoToken, ProtectScopeFunctionName, null), [
      new(null, new NameSegment(SourceOrigin.NoToken, varname, null)),
      new(null, new StringLiteralExpr(SourceOrigin.NoToken, varname, false)),
    ], Token.NoToken);
  }
}
