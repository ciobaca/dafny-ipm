#nullable enable
using Microsoft.Boogie;
using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Diagnostics.Contracts;
using System.Linq;

namespace Microsoft.Dafny;
public class ProtectRewriter(ErrorReporter r) : IRewriter(r) { // TODO: Figure out if the class can Extend Rewriter instead of IRewriter
  private class ExprReplacer {
    public static Expression ReplaceExpr(Expression e) => e switch {
      ApplyExpr p                           => ReplaceExprParticular(p),
      FunctionCallExpr p                    => ReplaceExprParticular(p),
      MemberSelectExpr p                    => ReplaceExprParticular(p),
      MultiSelectExpr p                     => ReplaceExprParticular(p),
      SeqSelectExpr p                       => ReplaceExprParticular(p),
      ThisExpr p                            => p switch {
        ImplicitThisExpr pp => pp switch {
          ImplicitThisExprConstructorCall ppp => ReplaceExprParticular(ppp),
          _ => ReplaceExprParticular(pp), },
        _ => ReplaceExprParticular(p), },
      DisplayExpression p                   => p switch {
        SeqDisplayExpr pp      => ReplaceExprParticular(pp),
        SetDisplayExpr pp      => ReplaceExprParticular(pp),
        MultiSetDisplayExpr pp => ReplaceExprParticular(pp),
        _ => ReplaceExprParticular(p), },
      MapDisplayExpr p                      => ReplaceExprParticular(p),
      MultiSetFormingExpr p                 => ReplaceExprParticular(p),
      SeqConstructionExpr p                 => ReplaceExprParticular(p),
      SeqUpdateExpr p                       => ReplaceExprParticular(p),
      ComprehensionExpr p                   => p switch {
        LambdaExpr pp       => ReplaceExprParticular(pp),
        MapComprehension pp => ReplaceExprParticular(pp),
        QuantifierExpr pp   => pp switch {
          ForallExpr ppp  => ReplaceExprParticular(ppp),
          ExistsExpr ppp  => ReplaceExprParticular(ppp),
          _ => ReplaceExprParticular(pp), },
        SetComprehension pp => ReplaceExprParticular(pp),
        _ => ReplaceExprParticular(p), },
      ITEExpr p                             => ReplaceExprParticular(p),
      NestedMatchExpr p                     => ReplaceExprParticular(p),
      TernaryExpr p                         => ReplaceExprParticular(p),
      DatatypeValue p                       => ReplaceExprParticular(p),
      FieldLocation p                       => ReplaceExprParticular(p),
      IndexFieldLocation p                  => ReplaceExprParticular(p),
      LocalsObjectExpression p              => ReplaceExprParticular(p),
      OldExpr p                             => ReplaceExprParticular(p),
      UnchangedExpr p                       => ReplaceExprParticular(p),
      WildcardExpr p                        => ReplaceExprParticular(p),
      BinaryExpr p                          => ReplaceExprParticular(p),
      DecreasesToExpr p                     => ReplaceExprParticular(p),
      UnaryExpr p                           => p switch {
        UnaryOpExpr pp    => pp switch {
          FreshExpr ppp => ReplaceExprParticular(ppp),
          _ => ReplaceExprParticular(pp), },
        TypeUnaryExpr pp  => pp switch {
          ConversionExpr ppp  => ReplaceExprParticular(ppp),
          TypeTestExpr ppp    => ReplaceExprParticular(ppp),
          _ => ReplaceExprParticular(pp), },
        _ => ReplaceExprParticular(p), },
      BoxingCastExpr p                      => ReplaceExprParticular(p),
      UnboxingCastExpr p                    => ReplaceExprParticular(p),
      IdentifierExpr p                      => p switch {
        AutoGhostIdentifierExpr pp  => ReplaceExprParticular(pp),
        ImplicitIdentifierExpr pp   => ReplaceExprParticular(pp),
        _ => ReplaceExprParticular(p), },
      LetExpr p                             => p switch {
        BoogieGenerator.SubstLetExpr pp => ReplaceExprParticular(pp),
        _ => ReplaceExprParticular(p), },
      ResolverIdentifierExpr p              => ReplaceExprParticular(p),
      ConcreteSyntaxExpression p            => p switch {
        NameSegment pp            => ReplaceExprParticular(pp),
        SuffixExpr pp             => pp switch {
          ApplySuffix ppp                   => ReplaceExprParticular(ppp),
          ExprDotName ppp                   => ReplaceExprParticular(ppp),
          FieldLocationExpression ppp       => ReplaceExprParticular(ppp),
          IndexFieldLocationExpression ppp  => ReplaceExprParticular(ppp),
          _ => ReplaceExprParticular(pp), },
        DatatypeUpdateExpr pp     => ReplaceExprParticular(pp),
        ChainingExpression pp     => ReplaceExprParticular(pp),
        ParensExpression pp       => pp switch {
          AutoGeneratedExpression ppp => ReplaceExprParticular(ppp),
          _ => ReplaceExprParticular(pp), },
        LetOrFailExpr pp          => ReplaceExprParticular(pp),
        DefaultValueExpression pp => pp switch {
          DefaultValueExpressionType ppp    => ReplaceExprParticular(ppp),
          DefaultValueExpressionPreType ppp => ReplaceExprParticular(ppp),
          _ => ReplaceExprParticular(pp), },
        NegationExpression pp     => ReplaceExprParticular(pp),
        _ => ReplaceExprParticular(p), },
      LiteralExpr p                         => p switch {
        StaticReceiverExpr pp => ReplaceExprParticular(pp),
        CharLiteralExpr pp    => ReplaceExprParticular(pp),
        StringLiteralExpr pp  => ReplaceExprParticular(pp),
        _ => ReplaceExprParticular(p), },
      StmtExpr p                            => ReplaceExprParticular(p),
      MatchExpr p                           => ReplaceExprParticular(p),
      BoogieGenerator.BoogieWrapper p       => ReplaceExprParticular(p),
      BoogieGenerator.BoogieFunctionCall p  => ReplaceExprParticular(p),
      _ => ReplaceExprParticular(e),
    };
    private static Expression NotImplemented(Expression e) {
      Console.WriteLine($"Dafny IPM: {e.GetType().Name} not yet implemented.");
      return e;
    }
    private static Expression ReplaceExprParticular(Expression e) => NotImplemented(e);
    private static Expression ReplaceExprParticular(StaticReceiverExpr e) => e;
    private static Expression ReplaceExprParticular(LiteralExpr e) => e;
    private static Expression ReplaceExprParticular(ThisExpr e) => ExpressionWrappedIn_Protect_Call(e);
    private static Expression ReplaceExprParticular(IdentifierExpr e) => ExpressionWrappedIn_Protect_Call(e);
    private static Expression ReplaceExprParticular(DatatypeValue e) => ExpressionWrappedIn_Protect_Call(e);
    private static Expression ReplaceExprParticular(NameSegment e) => ExpressionWrappedIn_Protect_Call(e);
    private static Expression ReplaceExprParticular(UnaryOpExpr e) {
      Contract.Assert(e.Op != UnaryOpExpr.Opcode.Fresh); // apparently this is unreachable since unary expressions are handled by the "FreshExpr" subclass
      return e.Op switch {
        UnaryOpExpr.Opcode.Cardinality  or
        UnaryOpExpr.Opcode.Allocated    or
        UnaryOpExpr.Opcode.Lit          or
        UnaryOpExpr.Opcode.Assigned     or
        UnaryOpExpr.Opcode.Not          => NotImplemented(e),
        _ => throw new UnreachableException(),
      };
    }
    private static Expression ReplaceExprParticular(BinaryExpr e) => new BinaryExpr(e.Origin, e.Op, ReplaceExpr(e.E0), ReplaceExpr(e.E1));
    private static Expression ReplaceExprParticular(ChainingExpression e) {
      if (e.PrefixLimits.Any(l => l is not null)) {
        return NotImplemented(e);
      }
      return new ChainingExpression(e.Origin, e.Operands.ConvertAll(ReplaceExpr), e.Operators, e.OperatorLocs, e.PrefixLimits);
    }
    private static Expression ReplaceExprParticular(ParensExpression e) => new ParensExpression(e.Origin, ReplaceExpr(e.E));
    private static Expression ReplaceExprParticular(DefaultValueExpression e) {
      Contract.Assert(e.WasResolved());
      Contract.Assert(e.Resolved is not null);
      return NotImplemented(e);
    }
  }

  static ProtectRewriter() {
    ProtectorFunctionNames = ["_protect", "_protectToProve",];
  }

  public static IReadOnlyList<string> ProtectorFunctionNames { get; }
  private static TypeParameter simpleTypeVar(string name) => new(
    origin: SourceOrigin.NoToken,
    nameNode: new(name),
    varianceSyntax: TPVarianceSyntax.NonVariant_Strict,
    characteristics: TypeParameterCharacteristics.Default(),
    typeBounds: [],
    attributes: null
  );
  private static Function inScopeFunction { get {
      var typeVar = simpleTypeVar("T");
      return new(
        origin: new Token(),
        // can't use SourceOrigin.NoToken because ref. eq. to it
        // is used to ensure that DefaultModuleDefinitions are verified;
        // I do NOT like that piece of code (:
        nameNode: new("_isInScope"),
        hasStaticKeyword: false,
        isGhost: true,
        isOpaque: true,
        typeArgs: [typeVar],
        ins: [
          new(
          origin: SourceOrigin.NoToken,
          nameNode: new("x"),
          syntacticType: new UserDefinedType(typeVar),
          inParam: true,
          isGhost: false,
          defaultValue: null,
          attributes: null,
          isOld: false,
          isNameOnly: false,
          isOlder: false,
          nameForCompilation: null
        ),
        ],
        result: null,
        resultType: new BoolType(),
        req: [],
        reads: new(),
        ens: [],
        decreases: new(),
        body: new LiteralExpr(
          origin: SourceOrigin.NoToken,
          value: true
        ),
        byMethodTok: null, byMethodBody: null,
        attributes: new(
          name: "auto_generated", args: [],
          prev: null
        ),
        signatureEllipsis: null
      );
    } }
  private static Function protectorFunctionWithName(string name) {
    var typeVar = simpleTypeVar("T");
    return new(
      origin: new Token(),
      nameNode: new(name),
      hasStaticKeyword: false,
      isGhost: true,
      isOpaque: true,
      typeArgs: [typeVar],
      ins: [
        new(
          origin: SourceOrigin.NoToken,
          nameNode: new("x"),
          syntacticType: new UserDefinedType(typeVar),
          inParam: true,
          isGhost: false,
          defaultValue: null,
          attributes: null,
          isOld: false,
          isNameOnly: false,
          isOlder: false,
          nameForCompilation: null
        ),
        new(
          origin: SourceOrigin.NoToken,
          nameNode: new("name"),
          syntacticType: new UserDefinedType(
            origin: SourceOrigin.NoToken,
            name: "string",
            optTypeArgs: null
          ),
          inParam: true,
          isGhost: false,
          defaultValue: null,
          attributes: null,
          isOld: false,
          isNameOnly: false,
          isOlder: false,
          nameForCompilation: null
        ),
      ],
      result: null,
      resultType: new UserDefinedType(typeVar),
      req: [],
      reads: new(),
      ens: [],
      decreases: new(),
      body: new NameSegment(
        origin: SourceOrigin.NoToken,
        name: "x",
        optTypeArguments: null
      ),
      byMethodTok: null, byMethodBody: null,
      attributes: new(
        name: "auto_generated", args: [],
        prev: null
      ),
      signatureEllipsis: null
    );
  }
  public static IReadOnlyList<Function> ProtectorFunctions { get {
      var r = ProtectorFunctionNames.Select(protectorFunctionWithName).ToList();
      r.Where(f => f.Name == ProtectorFunctionNames[1]).First().Ins.Add(new(
        origin: SourceOrigin.NoToken,
        nameNode: new("scope"),
        syntacticType: new SeqType(new BoolType()),
        inParam: true,
        isGhost: false,
        defaultValue: null,
        attributes: null,
        isOld: false,
        isNameOnly: false,
        isOlder: false,
        nameForCompilation: null
      ));
      return r;
    } }

  // TODOs:
  //  - figure out where you can call (some SystemModuleManager).CreateArrowTypeDecl(2) directly or deferred

  internal override void PreResolve(Program program) {
    //var moduleDefinition = new ModuleDefinition(
    //  SourceOrigin.NoToken,
    //  new Name("_ITP"),
    //  [],
    //  ModuleKindEnum.Concrete,
    //  null,
    //  program.DefaultModuleDef,
    //  null,
    //  []
    //);
    //var sig = new ModuleSignature() {
    //  ModuleDef = moduleDefinition,
    //  IsAbstract = moduleDefinition.ModuleKind == ModuleKindEnum.Abstract,
    //  VisibilityScope = new()
    //};
    //sig.VisibilityScope.Augment(moduleDefinition.VisibilityScope);
    //Contract.Assert(moduleDefinition.DefaultClass is not null);
    //moduleDefinition.DefaultClass.Members.AddRange(ProtectorFunctions);
    //moduleDefinition.DefaultClass.SetMembersBeforeResolution();
    //program.DefaultModuleDef.SourceDecls.Add(new LiteralModuleDecl(Options, moduleDefinition, program.DefaultModuleDef, Guid.NewGuid()));
    //  program.SystemModuleManager.CreateArrowTypeDecl(2);// this doesn't work for some reason, prolly bcs it's done after parsing :(
  }
  internal override void PreResolve(ModuleDefinition moduleDefinition) {
    Contract.Requires(moduleDefinition.DefaultClass is not null);
    Contract.Requires(moduleDefinition.TopLevelDecls.OfType<AbstractModuleDecl>().None());
    Contract.Requires(moduleDefinition.TopLevelDecls.None(d => d is TypeParameter or AmbiguousTopLevelDecl
                                                                 or InternalTypeSynonymDecl or NonNullTypeDecl));
    //moduleDefinition.SourceDecls.Add(new AliasModuleDecl(
    //  Options,
    //  new SourceOrigin(Token.NoToken, Token.NoToken)/*maybe this'll work?*/,
    //  new([new("_ITP")]),
    //  new("_ITP"),
    //  null,
    //  moduleDefinition,
    //  true,
    //  [],
    //  Guid.NewGuid()
    //));
    moduleDefinition.TopLevelDecls.Where(d => d is not ModuleDecl).ForEach(ApplyChangesTo);
    moduleDefinition.DefaultClass!.Members = [inScopeFunction, .. ProtectorFunctions, .. moduleDefinition.DefaultClass!.Members];
  }

  private static ApplySuffix ExpressionWrappedIn_Protect_Call(Expression expression) =>
    new(expression.Origin, null, new NameSegment(Token.NoToken, "_protect", null), [
      new(null, expression),
      new(null, new StringLiteralExpr(SourceOrigin.NoToken, expression.ToString(), false)),
    ], null);

  private static ApplySuffix ExpressionWrappedIn_ProtectToProve_Call(Expression expression) =>
    new(expression.Origin, null, new NameSegment(Token.NoToken, "_protectToProve", null), [
      new(null, ExprReplacer.ReplaceExpr(expression)),
      new(null, new StringLiteralExpr(SourceOrigin.NoToken, expression.ToString(), false)),
      new(null, new SeqDisplayExpr(SourceOrigin.NoToken, [])),
    ], null);

  private static void ApplyChangesTo(TopLevelDecl d) {
    static IEnumerable<AssertStmt> assertStatementsOfExpression(Expression e) {
      if (e is StmtExpr statementExpression) {
        foreach (var assertStatementFromStatementExpression in assertStatementsOfStatement(statementExpression.S)) {
          yield return assertStatementFromStatementExpression;
        }
      }
      foreach (var assertStatementFromSubExpressions in e.SubExpressions.SelectMany(assertStatementsOfExpression)) {
        yield return assertStatementFromSubExpressions;
      }
    }
    static IEnumerable<AssertStmt> assertStatementsOfStatement(Statement s) {
      if (s is AssertStmt assertStatement) {
        yield return assertStatement;
      }
      foreach (var assertStatementFromSubStatement in s.SubStatements.SelectMany(assertStatementsOfStatement)) {
        yield return assertStatementFromSubStatement;
      }
    }

    static void ReplaceExpressionInAssertStatement(AssertStmt a) {
      if (Attributes.Contains(a.Attributes, "ipm")) {
        //Console.WriteLine("Protecting to prove assertion " + a.Expr.ToString());
        a.Expr = ExpressionWrappedIn_ProtectToProve_Call(a.Expr);
      } else {
        a.Expr = ExprReplacer.ReplaceExpr(a.Expr);
        //Console.WriteLine($"assert statement: {a.Expr}");
      }
    }

    switch (d) {
      case TopLevelDeclWithMembers decl:
        foreach (var member in decl.Members.OfType<MethodOrFunction>()) {
          foreach (var req in member.Req) {
            req.E = ExprReplacer.ReplaceExpr(req.E);
            //Console.WriteLine($"requires clause: {req.E}");
          }
          foreach (var ens in member.Ens) {
            if (Attributes.Contains(ens.Attributes, "ipm")) {
              //Console.WriteLine("Protecting to prove ensures clause " + ens.E.ToString());
              ens.E = ExpressionWrappedIn_ProtectToProve_Call(ens.E);
            } else {
              ens.E = ExprReplacer.ReplaceExpr(ens.E);
            }
            //Console.WriteLine($"ensures clause: {ens.E}");
          }
          switch (member) {
            case Function f:
              if (f.Body is null) { break; }
              assertStatementsOfExpression(f.Body).ForEach(ReplaceExpressionInAssertStatement);
              break;
            case MethodOrConstructor mc:
              if (mc.Body is null) { break; }
              mc.Body.Body.SelectMany(assertStatementsOfStatement).ForEach(ReplaceExpressionInAssertStatement);
              break;
            default: throw new UnreachableException();
          }
        }
        break;
      case SubsetTypeDecl decl:
        assertStatementsOfExpression(decl.Constraint).ForEach(ReplaceExpressionInAssertStatement);
        if (decl.Witness is not null) {
          assertStatementsOfExpression(decl.Witness).ForEach(ReplaceExpressionInAssertStatement);
        }
        break;
      case ConcreteTypeSynonymDecl: break;
      default: throw new UnreachableException();
    }
  }

  public static ApplySuffix VariableNameWrappedIn_IsInScope_Call(string varname) {
    Contract.Ensures(Contract.Result<ApplySuffix>().Bindings.ArgumentBindings.Any(b => b.Actual is NameSegment _ns && _ns.Name == varname));
    return new(SourceOrigin.NoToken, null, new NameSegment(Token.NoToken, "_isInScope", null), [
      new(null, new NameSegment(SourceOrigin.NoToken, varname, null)),
    ], null);
  }

  #region common utils for AssertStmt and Ensures clauses
  public static bool IsProtectToProveCall(Expression e) => e is ApplySuffix {
    Lhs: NameSegment { Name: "_protectToProve" },
    Bindings.ArgumentBindings: [
      ActualBinding,
      ActualBinding { Actual: StringLiteralExpr, },
      ActualBinding { Actual: SeqDisplayExpr, },
    ],
  };
  public static bool IsValidProtectToProveCallPreResolve(Expression e) => IsProtectToProveCall(e) && ThirdArgSeq(e) is { Elements: [] };
  public static bool IsValidProtectToProveCallPostResolve(Expression e) => IsProtectToProveCall(e); // TODO: make this more restrictive
  public static SeqDisplayExpr ThirdArgSeq(Expression e) {
    Contract.Requires(IsProtectToProveCall(e));
    Contract.Ensures(IsProtectToProveCall(e));
    return ((e as ApplySuffix)!.Bindings.ArgumentBindings[2].Actual as SeqDisplayExpr)!;
  }
  #endregion
}
