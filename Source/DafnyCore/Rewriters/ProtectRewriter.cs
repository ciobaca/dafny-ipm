#nullable enable
using Microsoft.Boogie;
using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Diagnostics.Contracts;
using System.Linq;

namespace Microsoft.Dafny;
public class ProtectRewriter(ErrorReporter r) : IRewriter(r) { // TODO: Figure out if the class can Extend Rewriter instead of IRewriter
  private class Replacer {
    public static Expression ReplaceExpr(Expression e) => e switch {
      ApplyExpr p                           => ReplaceExprParticular(p),
      FunctionCallExpr p                    => ReplaceExprParticular(p),
      MemberSelectExpr p                    => ReplaceExprParticular(p),
      MultiSelectExpr p                     => ReplaceExprParticular(p),
      SeqSelectExpr p                       => ReplaceExprParticular(p),
      ThisExpr p                            => p switch {
        ImplicitThisExpr pp => pp switch {
          ImplicitThisExprConstructorCall ppp => ReplaceExprParticular(ppp),
          _ => ReplaceExprParticular(pp), },
        _ => ReplaceExprParticular(p), },
      DisplayExpression p                   => p switch {
        SeqDisplayExpr pp      => ReplaceExprParticular(pp),
        SetDisplayExpr pp      => ReplaceExprParticular(pp),
        MultiSetDisplayExpr pp => ReplaceExprParticular(pp),
        _ => ReplaceExprParticular(p), },
      MapDisplayExpr p                      => ReplaceExprParticular(p),
      MultiSetFormingExpr p                 => ReplaceExprParticular(p),
      SeqConstructionExpr p                 => ReplaceExprParticular(p),
      SeqUpdateExpr p                       => ReplaceExprParticular(p),
      ComprehensionExpr p                   => p switch {
        LambdaExpr pp       => ReplaceExprParticular(pp),
        MapComprehension pp => ReplaceExprParticular(pp),
        QuantifierExpr pp   => pp switch {
          ForallExpr ppp  => ReplaceExprParticular(ppp),
          ExistsExpr ppp  => ReplaceExprParticular(ppp),
          _ => ReplaceExprParticular(pp), },
        SetComprehension pp => ReplaceExprParticular(pp),
        _ => ReplaceExprParticular(p), },
      ITEExpr p                             => ReplaceExprParticular(p),
      NestedMatchExpr p                     => ReplaceExprParticular(p),
      TernaryExpr p                         => ReplaceExprParticular(p),
      DatatypeValue p                       => ReplaceExprParticular(p),
      FieldLocation p                       => ReplaceExprParticular(p),
      IndexFieldLocation p                  => ReplaceExprParticular(p),
      LocalsObjectExpression p              => ReplaceExprParticular(p),
      OldExpr p                             => ReplaceExprParticular(p),
      UnchangedExpr p                       => ReplaceExprParticular(p),
      WildcardExpr p                        => ReplaceExprParticular(p),
      BinaryExpr p                          => ReplaceExprParticular(p),
      DecreasesToExpr p                     => ReplaceExprParticular(p),
      UnaryExpr p                           => p switch {
        UnaryOpExpr pp    => pp switch {
          FreshExpr ppp => ReplaceExprParticular(ppp),
          _ => ReplaceExprParticular(pp), },
        TypeUnaryExpr pp  => pp switch {
          ConversionExpr ppp  => ReplaceExprParticular(ppp),
          TypeTestExpr ppp    => ReplaceExprParticular(ppp),
          _ => ReplaceExprParticular(pp), },
        _ => ReplaceExprParticular(p), },
      BoxingCastExpr p                      => ReplaceExprParticular(p),
      UnboxingCastExpr p                    => ReplaceExprParticular(p),
      IdentifierExpr p                      => p switch {
        AutoGhostIdentifierExpr pp  => ReplaceExprParticular(pp),
        ImplicitIdentifierExpr pp   => ReplaceExprParticular(pp),
        _ => ReplaceExprParticular(p), },
      LetExpr p                             => p switch {
        BoogieGenerator.SubstLetExpr pp => ReplaceExprParticular(pp),
        _ => ReplaceExprParticular(p), },
      ResolverIdentifierExpr p              => ReplaceExprParticular(p),
      ConcreteSyntaxExpression p            => p switch {
        NameSegment pp            => ReplaceExprParticular(pp),
        SuffixExpr pp             => pp switch {
          ApplySuffix ppp                   => ReplaceExprParticular(ppp),
          ExprDotName ppp                   => ReplaceExprParticular(ppp),
          FieldLocationExpression ppp       => ReplaceExprParticular(ppp),
          IndexFieldLocationExpression ppp  => ReplaceExprParticular(ppp),
          _ => ReplaceExprParticular(pp), },
        DatatypeUpdateExpr pp     => ReplaceExprParticular(pp),
        ChainingExpression pp     => ReplaceExprParticular(pp),
        ParensExpression pp       => pp switch {
          AutoGeneratedExpression ppp => ReplaceExprParticular(ppp),
          _ => ReplaceExprParticular(pp), },
        LetOrFailExpr pp          => ReplaceExprParticular(pp),
        DefaultValueExpression pp => pp switch { 
          DefaultValueExpressionType ppp    => ReplaceExprParticular(ppp),
          DefaultValueExpressionPreType ppp => ReplaceExprParticular(ppp),
          _ => ReplaceExprParticular(pp), },
        NegationExpression pp     => ReplaceExprParticular(pp),
        _ => ReplaceExprParticular(p), },
      LiteralExpr p                         => p switch {
        StaticReceiverExpr pp => ReplaceExprParticular(pp),
        CharLiteralExpr pp    => ReplaceExprParticular(pp),
        StringLiteralExpr pp  => ReplaceExprParticular(pp),
        _ => ReplaceExprParticular(p), },
      StmtExpr p                            => ReplaceExprParticular(p),
      MatchExpr p                           => ReplaceExprParticular(p),
      BoogieGenerator.BoogieWrapper p       => ReplaceExprParticular(p),
      BoogieGenerator.BoogieFunctionCall p  => ReplaceExprParticular(p),
      _ => ReplaceExprParticular(e),
    };
    private static Expression NotImplemented(Expression e) {
      Console.WriteLine($"Dafny IPM: {e.GetType().Name} not yet implemented.");
      return e;
    }
    private static Expression ReplaceExprParticular(Expression e) => NotImplemented(e);
    private static Expression ReplaceExprParticular(StaticReceiverExpr e) => e;
    private static Expression ReplaceExprParticular(LiteralExpr e) => e;
    private static Expression ReplaceExprParticular(ThisExpr e) => ExpressionWrappedIn_Protect_Call(e);
    private static Expression ReplaceExprParticular(IdentifierExpr e) => ExpressionWrappedIn_Protect_Call(e);
    private static Expression ReplaceExprParticular(DatatypeValue e) => ExpressionWrappedIn_Protect_Call(e);
    private static Expression ReplaceExprParticular(NameSegment e) => ExpressionWrappedIn_Protect_Call(e);
    private static Expression ReplaceExprParticular(UnaryOpExpr e) {
      Contract.Assert(e.Op != UnaryOpExpr.Opcode.Fresh); // apparently this is unreachable since unary expressions are handled by the "FreshExpr" subclass
      return e.Op switch {
        UnaryOpExpr.Opcode.Cardinality  or
        UnaryOpExpr.Opcode.Allocated    or
        UnaryOpExpr.Opcode.Lit          or
        UnaryOpExpr.Opcode.Assigned     or
        UnaryOpExpr.Opcode.Not          => NotImplemented(e),
        _ => throw new UnreachableException(),
      };
    }
    private static Expression ReplaceExprParticular(BinaryExpr e) => new BinaryExpr(e.Origin, e.Op, ReplaceExpr(e.E0), ReplaceExpr(e.E1));
    private static Expression ReplaceExprParticular(ChainingExpression e) {
      if (e.PrefixLimits.Any(l => l is not null)) {
        return NotImplemented(e);
      }
      return new ChainingExpression(e.Origin, e.Operands.ConvertAll(ReplaceExpr), e.Operators, e.OperatorLocs, e.PrefixLimits);
    }
    private static Expression ReplaceExprParticular(ParensExpression e) => new ParensExpression(e.Origin, ReplaceExpr(e.E));
    private static Expression ReplaceExprParticular(DefaultValueExpression e) {
      Contract.Assert(e.WasResolved());
      Contract.Assert(e.Resolved is not null);
      return NotImplemented(e);
    }
  }
  
  static ProtectRewriter() {
    ProtectorFunctionNames = ["_protect", "_protectToProve",];
  }
  public static IReadOnlyList<string> ProtectorFunctionNames { get; }
  private static Function protectorFunctionWithName(string name) {
    var typeVarForProtect = new TypeParameter(
      origin: SourceOrigin.NoToken,
      nameNode: new Name("T"),
      varianceSyntax: TPVarianceSyntax.NonVariant_Strict,
      characteristics: TypeParameterCharacteristics.Default(),
      typeBounds: [],
      attributes: null
    );
    return new(
      origin: SourceOrigin.NoToken,
      nameNode: new Name(name),
      hasStaticKeyword: false,
      isGhost: true,
      isOpaque: true,
      typeArgs: [typeVarForProtect],
      ins: [
        new Formal(
            origin: SourceOrigin.NoToken,
            nameNode: new Name("x"),
            syntacticType: new UserDefinedType(typeVarForProtect),
            inParam: true,
            isGhost: false,
            defaultValue: null,
            attributes: null,
            isOld: false,
            isNameOnly: false,
            isOlder: false,
            nameForCompilation: null
          ),
          new Formal(
            origin: SourceOrigin.NoToken,
            nameNode: new Name("name"),
            syntacticType: new UserDefinedType(
              origin: SourceOrigin.NoToken,
              name: "string",
              optTypeArgs: null
            ),
            inParam: true,
            isGhost: false,
            defaultValue: null,
            attributes: null,
            isOld: false,
            isNameOnly: false,
            isOlder: false,
            nameForCompilation: null
          )
      ],
      result: null,
      resultType: new UserDefinedType(typeVarForProtect),
      req: [],
      reads: new Specification<FrameExpression>(),
      ens: [],
      decreases: new Specification<Expression>(),
      body: new NameSegment(
        origin: SourceOrigin.NoToken,
        name: "x",
        optTypeArguments: null
      ),
      byMethodTok: null, byMethodBody: null,
      attributes: new Attributes(
        name: "auto_generated", args: [],
        prev: null
      ),
      signatureEllipsis: null
    );
  }
  public static IReadOnlyList<Function> ProtectorFunctions => [.. ProtectorFunctionNames.Select(protectorFunctionWithName)];

  //MASSIVE TODOs:
  //  - figure out where you can call (some SystemModuleManager).CreateArrowTypeDecl(2) directly or deferred

  internal override void PreResolve(Program program) {
    //var moduleDefinition = new ModuleDefinition(
    //  SourceOrigin.NoToken,
    //  new Name("_ITP"),
    //  [],
    //  ModuleKindEnum.Concrete,
    //  null,
    //  program.DefaultModuleDef,
    //  null,
    //  []
    //);
    //var sig = new ModuleSignature() {
    //  ModuleDef = moduleDefinition,
    //  IsAbstract = moduleDefinition.ModuleKind == ModuleKindEnum.Abstract,
    //  VisibilityScope = new()
    //};
    //sig.VisibilityScope.Augment(moduleDefinition.VisibilityScope);
    //Contract.Assert(moduleDefinition.DefaultClass is not null);
    //moduleDefinition.DefaultClass.Members.AddRange(ProtectorFunctions);
    //moduleDefinition.DefaultClass.SetMembersBeforeResolution();
    //program.DefaultModuleDef.SourceDecls.Add(new LiteralModuleDecl(Options, moduleDefinition, program.DefaultModuleDef, Guid.NewGuid()));
    //  program.SystemModuleManager.CreateArrowTypeDecl(2);// this doesn't work for some reason, prolly bcs it's done after parsing :(
  }
  internal override void PreResolve(ModuleDefinition moduleDefinition) {
    Contract.Requires(moduleDefinition.DefaultClass is not null);
    //moduleDefinition.SourceDecls.Add(new AliasModuleDecl(
    //  Options,
    //  new SourceOrigin(Token.NoToken, Token.NoToken)/*maybe this'll work?*/,
    //  new([new("_ITP")]),
    //  new("_ITP"),
    //  null,
    //  moduleDefinition,
    //  true,
    //  [],
    //  Guid.NewGuid()
    //));
    moduleDefinition.DefaultClass!.Members = [.. ProtectorFunctions, .. moduleDefinition.DefaultClass!.Members];
    Contract.Assert(!moduleDefinition.TopLevelDecls.OfType<AbstractModuleDecl>().Any());
    Contract.Assert(!moduleDefinition.TopLevelDecls.Any(d => d is TypeParameter or AmbiguousTopLevelDecl));
    Contract.Assert(!moduleDefinition.TopLevelDecls.Any(d => d is InternalTypeSynonymDecl or NonNullTypeDecl));
    moduleDefinition.TopLevelDecls.Where(d => d is not ModuleDecl).ForEach(ApplyChangesTo);
  }

  private static ApplySuffix ExpressionWrappedIn_Protect_Call(Expression expression) =>
    new(expression.Origin, null, new NameSegment(Token.NoToken, "_protect", null), [
      new ActualBinding(null, expression, false),
      new ActualBinding(null, new StringLiteralExpr(SourceOrigin.NoToken, expression.ToString(), false))
    ], null);

  //private static Expression WithProtect(Expression expr) {
  //  //void simplerLog<T>(T e) where T: Expression { logNotImplementedMessage(e, nameof(T)); }
  //  void logNotImplementedMessage(Expression e, string name) {
  //    Console.WriteLine($"Dafny IPM: {name} not yet implemented.");
  //    Console.WriteLine(expr.ToString());
  //  }
  //  Contract.Requires(expr != null);
  //  if (expr is StaticReceiverExpr) {
  //    return expr;
  //  } else if (expr is LiteralExpr) {
  //    return expr;
  //    //return to_protect_call_on_expr(expr);
  //  } else if (expr is ThisExpr or IdentifierExpr or DatatypeValue) {
  //    return ExpressionWrappedInProtectCall(expr);
  //  } else if (expr is NameSegment) {
  //    return ExpressionWrappedInProtectCall(expr);
  //  } else if (expr is BinaryExpr) {
  //    var e = expr as BinaryExpr;
  //    return new BinaryExpr(e.Origin, e.Op, WithProtect(e.E0), WithProtect(e.E1));
  //    // switch (e.Op)
  //    // {
  //    //   case BinaryExpr.Opcode.LeftShift:
  //    //   case BinaryExpr.Opcode.RightShift:
  //    //     opBindingStrength = BindingStrengthShift;
  //    //     fragileRightContext = true;
  //    //     break;
  //    //   case BinaryExpr.Opcode.Add:
  //    //     {
  //    //       opBindingStrength = BindingStrengthAdd;
  //    //       var t1 = e.E1.Type;
  //    //       fragileRightContext = t1 == null ||
  //    //                             !(t1.IsIntegerType || t1.IsRealType || t1.IsBigOrdinalType || t1.IsBitVectorType);
  //    //       break;
  //    //     }
  //    //   case BinaryExpr.Opcode.Sub:
  //    //     opBindingStrength = BindingStrengthAdd;
  //    //     fragileRightContext = true;
  //    //     break;
  //    //   case BinaryExpr.Opcode.Mul:
  //    //     {
  //    //       opBindingStrength = BindingStrengthMul;
  //    //       var t1 = e.E1.Type;
  //    //       fragileRightContext = t1 == null ||
  //    //                             !(t1.IsIntegerType || t1.IsRealType || t1.IsBigOrdinalType || t1.IsBitVectorType);
  //    //       break;
  //    //     }
  //    //   case BinaryExpr.Opcode.Div:
  //    //   case BinaryExpr.Opcode.Mod:
  //    //     opBindingStrength = BindingStrengthMul;
  //    //     fragileRightContext = true;
  //    //     break;
  //    //   case BinaryExpr.Opcode.BitwiseAnd:
  //    //     opBindingStrength = BindingStrengthBitwiseAnd; break;
  //    //   case BinaryExpr.Opcode.BitwiseOr:
  //    //     opBindingStrength = BindingStrengthBitwiseOr; break;
  //    //   case BinaryExpr.Opcode.BitwiseXor:
  //    //     opBindingStrength = BindingStrengthBitwiseXor; break;
  //    //   case BinaryExpr.Opcode.Eq:
  //    //   case BinaryExpr.Opcode.Neq:
  //    //   case BinaryExpr.Opcode.Gt:
  //    //   case BinaryExpr.Opcode.Ge:
  //    //   case BinaryExpr.Opcode.Lt:
  //    //   case BinaryExpr.Opcode.Le:
  //    //   case BinaryExpr.Opcode.Disjoint:
  //    //   case BinaryExpr.Opcode.In:
  //    //   case BinaryExpr.Opcode.NotIn:
  //    //     opBindingStrength = BindingStrengthCompare;
  //    //     fragileLeftContext = fragileRightContext = true;
  //    //     break;
  //    //   case BinaryExpr.Opcode.And:
  //    //     opBindingStrength = BindingStrengthAnd; break;
  //    //   case BinaryExpr.Opcode.Or:
  //    //     opBindingStrength = BindingStrengthOr; break;
  //    //   case BinaryExpr.Opcode.Imp:
  //    //     opBindingStrength = BindingStrengthImplies;
  //    //     fragileLeftContext = true;
  //    //     break;
  //    //   case BinaryExpr.Opcode.Exp:
  //    //     opBindingStrength = BindingStrengthExplies;
  //    //     fragileRightContext = true;
  //    //     break;
  //    //   case BinaryExpr.Opcode.Iff:
  //    //     opBindingStrength = BindingStrengthEquiv; break;
  //    //   default:
  //    //     Contract.Assert(false);
  //    //     throw new Cce.UnreachableException(); // unexpected binary operator
  //    // }

  //    // bool parensNeeded = ParensNeeded(opBindingStrength, contextBindingStrength, fragileContext);

  //    // string op = BinaryExpr.OpcodeString(e.Op);
  //    // if (parensNeeded)
  //    // {
  //    //   wr.Write("(");
  //    // }

  //    // var sem = !parensNeeded && isFollowedBySemicolon;
  //    // if (0 <= indent && e.Op == BinaryExpr.Opcode.And)
  //    // {
  //    //   PrintExpr(e.E0, opBindingStrength, fragileLeftContext, false, sem, indent, keyword);
  //    //   wr.WriteLine(" {0}", op);
  //    //   Indent(indent);
  //    //   PrintExpr(e.E1, opBindingStrength, fragileRightContext, parensNeeded || isRightmost, sem, indent, keyword);
  //    // }
  //    // else if (0 <= indent && e.Op == BinaryExpr.Opcode.Imp)
  //    // {
  //    //   PrintExpr(e.E0, opBindingStrength, fragileLeftContext, false, sem, indent, keyword);
  //    //   wr.WriteLine(" {0}", op);
  //    //   int ind = indent + IndentAmount;
  //    //   Indent(ind);
  //    //   PrintExpr(e.E1, opBindingStrength, fragileRightContext, parensNeeded || isRightmost, sem, ind, keyword);
  //    // }
  //    // else if (0 <= indent && e.Op == BinaryExpr.Opcode.Exp)
  //    // {
  //    //   PrintExpr(e.E1, opBindingStrength, fragileLeftContext, false, sem, indent, keyword);
  //    //   wr.WriteLine(" {0}", op);
  //    //   int ind = indent + IndentAmount;
  //    //   Indent(ind);
  //    //   PrintExpr(e.E0, opBindingStrength, fragileRightContext, parensNeeded || isRightmost, sem, ind, keyword);
  //    // }
  //    // else if (e.Op == BinaryExpr.Opcode.Exp)
  //    // {
  //    //   PrintExpr(e.E1, opBindingStrength, fragileLeftContext, false, sem, -1, keyword);
  //    //   wr.Write(" {0} ", op);
  //    //   PrintExpr(e.E0, opBindingStrength, fragileRightContext, parensNeeded || isRightmost, sem, -1, keyword);
  //    // }
  //    // else
  //    // {
  //    //   PrintExpr(e.E0, opBindingStrength, fragileLeftContext, false, sem, -1, keyword);
  //    //   wr.Write(" {0} ", op);
  //    //   PrintExpr(e.E1, opBindingStrength, fragileRightContext, parensNeeded || isRightmost, sem, -1, keyword);
  //    // }

  //    // if (parensNeeded)
  //    // {
  //    //   wr.Write(")");
  //    // }
  //  } else if (expr is TernaryExpr) {
  //    logNotImplementedMessage(expr, "TernaryExpr");
  //    return expr;
  //    // var e = (TernaryExpr)expr;
  //    // switch (e.Op)
  //    // {
  //    //   case TernaryExpr.Opcode.PrefixEqOp:
  //    //   case TernaryExpr.Opcode.PrefixNeqOp:
  //    //     var opBindingStrength = BindingStrengthCompare;
  //    //     var fragileLeftContext = true;
  //    //     var fragileRightContext = true;
  //    //     bool parensNeeded = ParensNeeded(opBindingStrength, contextBindingStrength, fragileContext);

  //    //     if (parensNeeded)
  //    //     {
  //    //       wr.Write("(");
  //    //     }

  //    //     var sem = !parensNeeded && isFollowedBySemicolon;
  //    //     PrintExpr(e.E1, opBindingStrength, fragileLeftContext, false, sem, -1, keyword);
  //    //     wr.Write(" {0}#[", e.Op == TernaryExpr.Opcode.PrefixEqOp ? "==" : "!=");
  //    //     PrintExpression(e.E0, false);
  //    //     wr.Write("] ");
  //    //     PrintExpr(e.E2, opBindingStrength, fragileRightContext, parensNeeded || isRightmost, sem, -1, keyword);
  //    //     if (parensNeeded)
  //    //     {
  //    //       wr.Write(")");
  //    //     }

  //    //     break;
  //    //   default:
  //    //     Contract.Assert(false); // unexpected ternary operator
  //    //     break;
  //    // }
  //  } else if (expr is ChainingExpression) {
  //    var e = expr as ChainingExpression;
  //    if (e.PrefixLimits.Any(pl => pl != null)) {
  //      logNotImplementedMessage(expr, "ChainingExpression prefixLimits");
  //      return expr;
  //    }
  //    return new ChainingExpression(e.Origin, [.. e.Operands.Select(WithProtect)], e.Operators, e.OperatorLocs, e.PrefixLimits);
  //    // // determine if parens are needed
  //    // int opBindingStrength = BindingStrengthCompare;
  //    // bool parensNeeded = ParensNeeded(opBindingStrength, contextBindingStrength, fragileContext);

  //    // if (parensNeeded)
  //    // {
  //    //   wr.Write("(");
  //    // }

  //    // var sem = !parensNeeded && isFollowedBySemicolon;
  //    // PrintExpr(e.Operands[0], opBindingStrength, true, false, sem, -1, keyword);
  //    // for (int i = 0; i < e.Operators.Count; i++)
  //    // {
  //    //   string op = BinaryExpr.OpcodeString(e.Operators[i]);
  //    //   if (e.PrefixLimits[i] == null)
  //    //   {
  //    //     wr.Write(" {0} ", op);
  //    //   }
  //    //   else
  //    //   {
  //    //     wr.Write(" {0}#[", op);
  //    //     PrintExpression(e.PrefixLimits[i], false);
  //    //     wr.Write("] ");
  //    //   }

  //    //   PrintExpr(e.Operands[i + 1], opBindingStrength, true,
  //    //     i == e.Operators.Count - 1 && (parensNeeded || isRightmost), sem, -1, keyword);
  //    // }

  //    // if (parensNeeded)
  //    // {
  //    //   wr.Write(")");
  //    // }
  //  } else if (expr is ParensExpression) {
  //    ParensExpression e = (ParensExpression)expr;
  //    return new ParensExpression(expr.Origin, WithProtect(e.E));
  //  } else if (expr is DefaultValueExpression) {
  //    // DefaultValueExpression's are introduced during resolution, so we expect .Resolved to be non-null
  //    Contract.Assert(expr.WasResolved());
  //    Contract.Assert(expr.Resolved != null);
  //    logNotImplementedMessage(expr, "DefaultValueExpression");
  //    return expr;
  //  } else {
  //    Console.WriteLine("Dafny IPM: Unexpected expression type.");
  //    Console.WriteLine(expr.ToString());
  //    Contract.Assert(false);
  //    return expr;
  //  }
  //}

  private static Expression ExpressionWrappedIn_ProtectToProve_Call(Expression e) =>
    new ApplySuffix(e.Origin, null, new NameSegment(Token.NoToken, "_protectToProve", null), [
      new ActualBinding(null, Replacer.ReplaceExpr(e), false),
      new ActualBinding(null, new StringLiteralExpr(SourceOrigin.NoToken, e.ToString(), false))
    ], null);

  private static void ApplyChangesTo(TopLevelDecl d) {
    static IEnumerable<AssertStmt> assertStatementsOfExpression(Expression e) {
      if (e is StmtExpr statementExpression) {
        foreach (var assertStatementFromStatementExpression in assertStatementsOfStatement(statementExpression.S)) {
          yield return assertStatementFromStatementExpression;
        }
      }
      foreach (var assertStatementFromSubExpressions in e.SubExpressions.SelectMany(assertStatementsOfExpression)) {
        yield return assertStatementFromSubExpressions;
      }
    }
    static IEnumerable<AssertStmt> assertStatementsOfStatement(Statement s) {
      if (s is AssertStmt assertStatement) {
        yield return assertStatement;
      }
      foreach (var assertStatementFromSubStatement in s.SubStatements.SelectMany(assertStatementsOfStatement)) {
        yield return assertStatementFromSubStatement;
      }
    }

    static void ReplaceExpressionInAssertStatement(AssertStmt a) {
      if (Attributes.Contains(a.Attributes, "itp")) {
        Console.WriteLine("Protecting to prove assertion " + a.Expr.ToString());
        a.Expr = ExpressionWrappedIn_ProtectToProve_Call(a.Expr);
      } else {
        a.Expr = Replacer.ReplaceExpr(a.Expr);
        Console.WriteLine($"assert statement: {a.Expr}");
      }
    }
    
    switch (d) {
      case TopLevelDeclWithMembers decl:
        foreach (var member in decl.Members.OfType<MethodOrFunction>()) {
          foreach (var req in member.Req) {
            req.E = Replacer.ReplaceExpr(req.E);
            Console.WriteLine($"requires clause: {req.E}");
          }
          foreach (var ens in member.Ens) {
            if (Attributes.Contains(ens.Attributes, "itp")) {
              Console.WriteLine("Protecting to prove ensures clause " + ens.E.ToString());
              ens.E = ExpressionWrappedIn_ProtectToProve_Call(ens.E);
            } else {
              ens.E = Replacer.ReplaceExpr(ens.E);
            }
            Console.WriteLine($"ensures clause: {ens.E}");
          }
          switch (member) {
            case Function f:
              if (f.Body is null) { break; }
              assertStatementsOfExpression(f.Body).ForEach(ReplaceExpressionInAssertStatement);
              break;
            case MethodOrConstructor mc:
              if (mc.Body is null) { break; }
              mc.Body.Body.SelectMany(assertStatementsOfStatement).ForEach(ReplaceExpressionInAssertStatement);
              break;
            //case Constructor c:
            //  if (c.Body is null) { break; }
            //  c.Body.Body.SelectMany(assertStatementsOfStatement).ForEach(ReplaceExpressionInAssertStatement);
            //  break;
            //case Method m:
            //  if (m.Body is null) { break; }
            //  m.Body.Body.SelectMany(assertStatementsOfStatement).ForEach(ReplaceExpressionInAssertStatement);
            //  break;
            default: throw new UnreachableException();
          }
        }
        break;
      case SubsetTypeDecl decl:
        assertStatementsOfExpression(decl.Constraint).ForEach(ReplaceExpressionInAssertStatement);
        if (decl.Witness is not null) {
          assertStatementsOfExpression(decl.Witness).ForEach(ReplaceExpressionInAssertStatement);
        }
        break;
      case ConcreteTypeSynonymDecl: break;
      default: throw new UnreachableException();
    }
  }
}
