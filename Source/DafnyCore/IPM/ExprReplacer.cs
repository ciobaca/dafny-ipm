using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Diagnostics.Contracts;
using System.Linq;
using Microsoft.Dafny;

namespace DafnyCore.IPM {
  public class ExprReplacer {
    public static Expression ReplaceExpr(Expression e) => e switch {
      ApplyExpr p                           => ReplaceExprParticular(p),
      FunctionCallExpr p                    => ReplaceExprParticular(p),
      MemberSelectExpr p                    => ReplaceExprParticular(p),
      MultiSelectExpr p                     => ReplaceExprParticular(p),
      SeqSelectExpr p                       => ReplaceExprParticular(p),
      ThisExpr p                            => p switch {
        ImplicitThisExpr pp => pp switch {
          ImplicitThisExprConstructorCall ppp => ReplaceExprParticular(ppp),
          _ => ReplaceExprParticular(pp), },
        _ => ReplaceExprParticular(p), },
      DisplayExpression p                   => p switch {
        SeqDisplayExpr pp      => ReplaceExprParticular(pp),
        SetDisplayExpr pp      => ReplaceExprParticular(pp),
        MultiSetDisplayExpr pp => ReplaceExprParticular(pp),
        _ => ReplaceExprParticular(p), },
      MapDisplayExpr p                      => ReplaceExprParticular(p),
      MultiSetFormingExpr p                 => ReplaceExprParticular(p),
      SeqConstructionExpr p                 => ReplaceExprParticular(p),
      SeqUpdateExpr p                       => ReplaceExprParticular(p),
      ComprehensionExpr p                   => p switch {
        LambdaExpr pp       => ReplaceExprParticular(pp),
        MapComprehension pp => ReplaceExprParticular(pp),
        QuantifierExpr pp   => pp switch {
          ForallExpr ppp  => ReplaceExprParticular(ppp),
          ExistsExpr ppp  => ReplaceExprParticular(ppp),
          _ => ReplaceExprParticular(pp), },
        SetComprehension pp => ReplaceExprParticular(pp),
        _ => ReplaceExprParticular(p), },
      ITEExpr p                             => ReplaceExprParticular(p),
      NestedMatchExpr p                     => ReplaceExprParticular(p),
      TernaryExpr p                         => ReplaceExprParticular(p),
      DatatypeValue p                       => ReplaceExprParticular(p),
      FieldLocation p                       => ReplaceExprParticular(p),
      IndexFieldLocation p                  => ReplaceExprParticular(p),
      LocalsObjectExpression p              => ReplaceExprParticular(p),
      OldExpr p                             => ReplaceExprParticular(p),
      UnchangedExpr p                       => ReplaceExprParticular(p),
      WildcardExpr p                        => ReplaceExprParticular(p),
      BinaryExpr p                          => ReplaceExprParticular(p),
      DecreasesToExpr p                     => ReplaceExprParticular(p),
      UnaryExpr p                           => p switch {
        UnaryOpExpr pp    => pp switch {
          FreshExpr ppp => ReplaceExprParticular(ppp),
          _ => ReplaceExprParticular(pp), },
        TypeUnaryExpr pp  => pp switch {
          ConversionExpr ppp  => ReplaceExprParticular(ppp),
          TypeTestExpr ppp    => ReplaceExprParticular(ppp),
          _ => ReplaceExprParticular(pp), },
        _ => ReplaceExprParticular(p), },
      BoxingCastExpr p                      => ReplaceExprParticular(p),
      UnboxingCastExpr p                    => ReplaceExprParticular(p),
      IdentifierExpr p                      => p switch {
        AutoGhostIdentifierExpr pp  => ReplaceExprParticular(pp),
        ImplicitIdentifierExpr pp   => ReplaceExprParticular(pp),
        _ => ReplaceExprParticular(p), },
      LetExpr p                             => p switch {
        BoogieGenerator.SubstLetExpr pp => ReplaceExprParticular(pp),
        _ => ReplaceExprParticular(p), },
      ResolverIdentifierExpr p              => ReplaceExprParticular(p),
      ConcreteSyntaxExpression p            => p switch {
        NameSegment pp            => ReplaceExprParticular(pp),
        SuffixExpr pp             => pp switch {
          ApplySuffix ppp                   => ReplaceExprParticular(ppp),
          ExprDotName ppp                   => ReplaceExprParticular(ppp),
          FieldLocationExpression ppp       => ReplaceExprParticular(ppp),
          IndexFieldLocationExpression ppp  => ReplaceExprParticular(ppp),
          _ => ReplaceExprParticular(pp), },
        DatatypeUpdateExpr pp     => ReplaceExprParticular(pp),
        ChainingExpression pp     => ReplaceExprParticular(pp),
        ParensExpression pp       => pp switch {
          AutoGeneratedExpression ppp => ReplaceExprParticular(ppp),
          _ => ReplaceExprParticular(pp), },
        LetOrFailExpr pp          => ReplaceExprParticular(pp),
        DefaultValueExpression pp => pp switch {
          DefaultValueExpressionType ppp    => ReplaceExprParticular(ppp),
          DefaultValueExpressionPreType ppp => ReplaceExprParticular(ppp),
          _ => ReplaceExprParticular(pp), },
        NegationExpression pp     => ReplaceExprParticular(pp),
        _ => ReplaceExprParticular(p), },
      LiteralExpr p                         => p switch {
        StaticReceiverExpr pp => ReplaceExprParticular(pp),
        CharLiteralExpr pp    => ReplaceExprParticular(pp),
        StringLiteralExpr pp  => ReplaceExprParticular(pp),
        _ => ReplaceExprParticular(p), },
      StmtExpr p                            => ReplaceExprParticular(p),
      MatchExpr p                           => ReplaceExprParticular(p),
      BoogieGenerator.BoogieWrapper p       => ReplaceExprParticular(p),
      BoogieGenerator.BoogieFunctionCall p  => ReplaceExprParticular(p),
      _ => ReplaceExprParticular(e),
    };
    private static Expression NotImplemented(Expression e) {
      Console.WriteLine($"Dafny IPM: {e.GetType().Name} not yet implemented.");
      return e;
    }
    private static Expression ReplaceExprParticular(Expression e) => NotImplemented(e);
    private static Expression ReplaceExprParticular(StaticReceiverExpr e) => e;
    private static Expression ReplaceExprParticular(LiteralExpr e) => e;
    private static Expression ReplaceExprParticular(ThisExpr e) => ProtectFunction.CallOn(e);
    private static Expression ReplaceExprParticular(IdentifierExpr e) => ProtectFunction.CallOn(e);
    private static Expression ReplaceExprParticular(DatatypeValue e) => ProtectFunction.CallOn(e);
    private static Expression ReplaceExprParticular(NameSegment e) => ProtectFunction.CallOn(e);
    private static Expression ReplaceExprParticular(UnaryOpExpr e) {
      Contract.Assert(e.Op != UnaryOpExpr.Opcode.Fresh); // apparently this is unreachable since unary expressions are handled by the "FreshExpr" subclass
      return e.Op switch {
        UnaryOpExpr.Opcode.Cardinality  or
        UnaryOpExpr.Opcode.Allocated    or
        UnaryOpExpr.Opcode.Lit          or
        UnaryOpExpr.Opcode.Assigned     or
        UnaryOpExpr.Opcode.Not          => NotImplemented(e),
        _ => throw new UnreachableException(),
      };
    }
    private static Expression ReplaceExprParticular(BinaryExpr e) => new BinaryExpr(e.Origin, e.Op, ReplaceExpr(e.E0), ReplaceExpr(e.E1));
    private static Expression ReplaceExprParticular(ChainingExpression e) {
      if (e.PrefixLimits.Any(l => l is not null)) {
        return NotImplemented(e);
      }
      return new ChainingExpression(e.Origin, e.Operands.ConvertAll(ReplaceExpr), e.Operators, e.OperatorLocs, e.PrefixLimits);
    }
    private static Expression ReplaceExprParticular(ParensExpression e) => new ParensExpression(e.Origin, ReplaceExpr(e.E));
    private static Expression ReplaceExprParticular(DefaultValueExpression e) {
      Contract.Assert(e.WasResolved());
      Contract.Assert(e.Resolved is not null);
      return NotImplemented(e);
    }
    private static Expression ReplaceExprParticular(LetExpr e) => new LetExpr(e.Origin, e.LHSs, e.RHSs.ConvertAll(ReplaceExpr), ReplaceExpr(e.Body), e.Exact, e.Attributes);
    private static Expression ReplaceExprParticular(ApplySuffix e) => new ApplySuffix(
      e.Origin, e.AtTok, e.Lhs, e.Bindings.ArgumentBindings.ConvertAll(ab => new ActualBinding(ab.FormalParameterName, ReplaceExpr(ab.Actual), ab.IsGhost)), e.CloseParen
    );
    private static Expression ReplaceExprParticular(StmtExpr e) {
      Statement ReplaceExprInStatement(Statement s) => s switch { // TODO: complete everything here, only PredicateStmt is handled properly
        PredicateStmt stmt => stmt switch {
          AssertStmt assert => new AssertStmt(assert.Origin, ReplaceExpr(assert.Expr), assert.Label, assert.Attributes),
          AssumeStmt assume => new AssumeStmt(assume.Origin, assume.Expr, assume.Attributes),
          ExpectStmt expect => new ExpectStmt(expect.Origin, expect.Expr, expect.Message, expect.Attributes),
          _ => throw new Cce.UnreachableException(),
        },
        CalcStmt stmt => stmt,
        ForallStmt stmt => stmt,     // one could wrap a `forall` expression around the `ensures` clause, but "true" is conservative and much simpler :)
        HideRevealStmt stmt => stmt, // one could use the definition axiom or the referenced labeled assertions, but "true" is conservative and much simpler :)
        AssignStatement stmt => stmt,// one could use the postcondition of the method, suitably instantiated, but "true" is conservative and much simpler :)
        BlockByProofStmt stmt => stmt,
        _ => throw new Cce.UnreachableException(),  // unexpected statement
      };
      return new StmtExpr(e.Origin, ReplaceExprInStatement(e.S), ReplaceExpr(e.E));
    }
  }
}
